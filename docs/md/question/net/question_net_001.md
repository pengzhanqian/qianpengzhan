## 什么是全双工、半双工?

[[toc]]

> 说在前面的话，本文为日常开发过程中遇到的一些问题，整理记录成模块，方面后续遇到直接查询解决。

在计算机网络中，"全双工"和"半双工"描述了数据流动的方式：

### 1. ‌ 全双工通信(Full Duplex)

- ‌**定义**‌：通信双方可以‌**同时**‌发送和接收数据
- ‌特点：
  - 双向数据传输能力
  - 发送和接收操作并行进行
  - 需要独立的发送和接收信道
- ‌**类比**‌：电话通话（双方能同时说话和听对方说话）
- ‌**Java示例**‌：

```java
// 服务端响应客户端后继续监听新消息
client.write(ByteBuffer.wrap(response.getBytes())); // 发送响应
// 此时服务端可继续处理其他通道的请求
```

### 2. ‌ 半双工通信(Half Duplex)

- ‌**定义**‌：通信双方可以双向传输数据，但‌**不能同时**‌进行
- ‌特点：
  - 交替进行发送和接收
  - 某一时刻只能单向传输
  - 需要通信协议协调传输方向
- ‌**类比**‌：对讲机（按着说话键时不能听，松开才能听）
- ‌**Java示例**‌：

```java
// 服务端必须等待客户端发送完成才能响应
while((input = console.readLine()) != null) {
    out.println(input);  // 发送（此时不能接收）
    System.out.println("等待回复...");
    response = in.readLine();  // 接收（此时不能发送）
}
```

### 3. ‌ 单工通信(Simplex)

- ‌**定义**‌：数据只能‌**单向传输**‌
- ‌特点‌：
  - 固定方向的通信
  - 一方只能发送，另一方只能接收
- ‌**类比**‌：广播电台（电台只能发送，收音机只能接收）

### Java网络编程中的体现：

| 特性         | BIO示例           | NIO示例              |
| ------------ | ----------------- | -------------------- |
| ‌**连接类型**‌ | 全双工（TCP特性） | 全双工（TCP特性）    |
| ‌**实现方式**‌ | 半双工使用方式    | 真正的全双工实现     |
| ‌**原因**‌     | 单线程顺序处理    | 多路复用支持并发读写 |

### 关键区别图示：

```text
全双工：
  客户端 →→ 数据 →→ 服务端
  客户端 ←← 数据 ←← 服务端
  (双向同时传输)

半双工：
  客户端 →→ 数据 →→ 服务端
  (传输完成后)
  客户端 ←← 数据 ←← 服务端
  (交替传输)
```

在实际Java网络编程中：

1. ‌**TCP协议本身是全双工的**‌（底层支持双向同时传输）
2. ‌**BIO模型常表现为半双工**‌：因为单线程顺序处理请求/响应
3. ‌**NIO/AIO可实现真正全双工**‌：通过Selector多路复用，读写操作互不阻塞
4. ‌**WebSocket是全双工典型**‌：建立连接后双方可随时互发消息

> 建议：需要实时双向通信的场景（如聊天室、游戏）应使用NIO+WebSocket实现全双工，而简单的请求-响应场景可以使用半双工模式。