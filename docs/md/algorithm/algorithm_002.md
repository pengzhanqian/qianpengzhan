# 算法 - 认识复杂度

[[toc]]

> 说在前面的话，本文为个人学习[B站免费的左程云算法结构基础课](https://www.bilibili.com/video/BV1Ef4y1T7Qi/?spm_id_from=333.788.recommend_more_video.1&vd_source=65c7f6924d2d8ba5fa0d4c448818e08a)后进行总结的文章，主要是以`Java`来运行算法.

## 【1】算法的评估衡量指标

> ::: info 评估算法优劣的<b>核心指标</b>是什么?
>
> -  <b>时间复杂度</b> (流程决定)
> - <b>额外空间复杂度</b> (流程决定)
> - <b>常数项时间</b> (实现细节决定)
>
> :::

## 【2】时间复杂度

### 【2.1】了解常数时间的操作

> ::: important 什么是常数时间的操作?
>
> - <b>概念</b>
>   - 如果一个操作的<b>执行时间</b>不以<b>具体样本量</b>为转移，每次<b>执行时间</b>都是<b>固定时间</b>。我们称这样的操作为<b>常数时间的操作</b>。
> - <b>通俗的讲</b>
>   - 我们做一件事情，无论这个时间多么复杂，事情的数量多少，我们做某种操作都是需要花费相同的时间，那么这个操作就是叫做<b>常数时间的操作</b>
>
> - <b>例子: 数组寻址</b>
>   - 比如我们有1个数组，这个数组里面我们知道数字8在他的下标为10的位置，那么无论这个数组多大，当我们取数字8的时候，我们都是直接找这个下标10即可，每次花费的时间都是固定的。故我们称获取数组中的数字8的这个操作叫做<b>常数时间的操作</b>
> - <b>有哪些常数时间的操作</b>
>   - 常见的算术运算(`+`, `-`, `*`, `\`, `%`等)
>   - 常见的位运算(`>>(带符号位的右移)`, `>>>(不带符号位的右移)`，`<<`，`|`，`&`，`^`)
>   - 赋值、比较、自增、自减操作等
>   - 数组寻址查询操作
> - <b>总结</b>
>   - 总之，执行时间固定的操作都是<b>常数时间的操作</b>
>   - 反之，执行时间不固定的操作，都不是<b>常数时间的操作</b>
>     - `LinkedList`,底层是<b>双向链表</b>,为不连续的，靠指针去判断，是需要遍历的，则它的`get(i)`的操作就不是<b>常数时间的操作</b>
>
> :::

### 【2.2】时间复杂度

#### 【2.2.1】定义

> ::: info 定义
>
> <b>时间复杂度</b>是计算机科学中用来‌**量化算法运行时间如何随着输入规模增长而增加**‌的度量标准。它不是直接计算算法运行的实际秒数（这取决于硬件、编程语言和具体实现），而是‌**描述运行时间的增长趋势**‌。
>
> :::

#### 【2.2.2】核心概念

> - <b>输入规模 (`n`)：</b> 代表算法处理的数据量大小。例如：
>   - 排序算法中，`n` 是待排序元素的数量。
>   - 搜索算法中，`n` 是搜索空间（如数组长度或树中节点数）。
>   - 图算法中，`n` 可能是顶点数或边数。
> - <b>基本操作：</b>  算法中最耗时的关键操作（通常假设其执行时间是常数）。例如：
>   - 比较两个元素的大小。
>   - 算术运算（加、减、乘、除）。
>   - 数组元素的访问或赋值。
>   - 函数调用（有时）。
> - ‌<b>增长趋势：</b>  <b>时间复杂度</b>关注的是当 `n` ‌**变得非常大**‌时，执行基本操作的次数 `T(n)` 如何增长。我们忽略：
>   - 低阶项 (`3n`, `2n` 中的 `3`, `2`)。
>   - 常数因子 (`5`, `100`)。
>   - 输入规模较小时的表现（我们关心大规模数据下的性能）。

#### 【2.2.3】时间复杂度的表示法

> <b>时间复杂度</b>通常用‌**大 O 符号**‌表示，写作 `O(f(n))`。它表示算法运行时间的‌**上界**‌或‌**增长率**‌。
>
> - `O(f(n))` 意味着存在常数 `c > 0` 和某个输入规模 `n0`，使得对于所有 `n >= n0`，算法的实际运行时间 `T(n)` 满足：
>    `T(n) <= c * f(n)`

> **通俗的理解** ：
>
> <b>时间复杂度</b> 就是当完成了表达式的建立，只要把最高阶项留下即可，低阶项都去掉，高阶项的系数也去掉。记为：`O(忽略到系数的高阶项)`

#### 【2.2.4】为什么时间复杂度很重要？

> - <b>比较算法效率：</b> 允许我们在不实际运行代码的情况下，比较不同算法解决同一问题的效率。一个 `O(n log n)` 的排序算法通常比 `O(n²)` 的算法在大规模数据上快得多。
> - <b>预测性能：</b> 帮助我们理解算法在处理更大数据集时的表现。如果一个算法是 `O(2ⁿ)`，输入规模稍微增加一点，运行时间就可能爆炸式增长（不可行）；而一个 `O(n)` 的算法，输入规模加倍，运行时间大致也只需翻倍。
> - <b>设计高效算法：</b> 是算法设计和分析的基础，指导我们选择或开发更优的解决方案。
> - <b>简化分析：</b> 关注主导因素（增长率），忽略依赖具体实现环境的细节。

> **通俗的理解如下**:  
>
> - <b>时间复杂度</b>的意义在于当我们要处理的样本数量很大很大的时候，我们会发先低阶项是什么已经不重要了，每一项的系数是什么，也变得不重要了。最重要的时候是最高阶项是什么。  这就是<b>时间复杂度</b>的意义。它是衡量算法流程的一种指标，该指标只与数据量有关，与过程之外的优化无关。

#### 【2.2.5】常见的时间复杂度

>  常见的<b>时间复杂度</b>（从小到大，效率从高到低）

| 时间复杂度        | 名称         | 描述                                                         | 典型例子                                                |
| ----------------- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------- |
| ‌<b>O(1)</b>       | 常数时间     | 运行时间与输入规模 `n` ‌**无关**‌。是最理想的复杂度。          | 访问数组元素、哈希表查找（理想情况下）、数学运算        |
| ‌<b>O(log n)</b>   | 对数时间     | 运行时间随 `n` ‌**对数增长**‌。即使 `n` 很大，运行时间增长也很缓慢。非常高效。 | 二分查找、平衡二叉搜索树操作                            |
| ‌‌<b>O(n)</b>       | 线性时间     | 运行时间与 `n` ‌**成正比增长**‌。输入加倍，运行时间大致加倍。常见且高效。 | 遍历数组或链表、找最大值                                |
| ‌<b>O(n log n)</b> | 线性对数时间 | 运行时间比线性略慢，但远优于二次方。许多高效算法的复杂度。   | 快速排序（平均情况）、归并排序、堆排序                  |
| ‌‌<b>O(n²)</b>      | 二次方时间   | 运行时间与 `n²` ‌**成正比增长**‌。输入加倍，运行时间大致变为四倍。效率较低，对小规模数据尚可。 | 冒泡排序、选择排序、插入排序（最坏/平均）、简单嵌套循环 |
| ‌‌<b>O(n³)</b>      | 三次方时间   | 运行时间与 `n³` ‌**成正比增长**‌。输入稍微增大，运行时间就会显著变慢。 | 简单矩阵乘法、三层嵌套循环                              |
| ‌<b>O(2ⁿ)</b>      | 指数时间     | 运行时间‌**指数级增长**‌（翻倍）。即使 `n` 很小，运行时间也可能巨大。‌**通常不可行**。‌ | 穷举搜索（如旅行商问题的暴力解法）、某些递归算法        |
| ‌<b>O(n!)</b>      | 阶乘时间     | 运行时间随 `n` ‌**阶乘增长**‌。增长极其迅速，‌**极其低效**‌。    | 生成所有排列、旅行商问题的暴力解法                      |

#### 【2.2.8】计算方法

> ::: important  如何确定算法流程的总操作数量和样本数量之间的关系？
>
> - 想象该算法流程所处理的数据状况，要按照<b>最差的情况</b>来算
> - 把整个流程彻底拆分为一个个基本动作，保证每个动作都是<b>常数时间的操作</b>
> - 如果数据量为N,看看基本动作的数量和N是什么关系
>
> :::

#### 【2.2.7】注意事项

> ::: warning 重要的注意事项
>
> - <b>最坏情况 vs 平均情况：</b> <b>时间复杂度</b>可以分析最坏情况（算法在任何输入下所需的最长时间）或平均情况（算法在随机输入下的期望运行时间）。讨论时必须明确是哪种情况（例如，快速排序的最坏情况是 `O(n²)`，但平均情况是高效的 `O(n log n)`）。
> - <b>大 O 是上界：</b> `O(n)` 也表示算法是 `O(n²)` 和 `O(n³)`，因为 `O` 表示的是一个上界。但我们总是寻找最“紧”的上界（即最小的增长率函数）来描述算法的复杂度。
> - <b>空间复杂度：</b> 这是另一个关键指标，衡量算法运行所需的内存量如何随 `n` 增长（也用大 O 表示）。<b>时间复杂度</b>和<b>空间复杂度</b>常常需要权衡。
> - <b>常数因子：</b> 大 O 忽略了常数因子。一个运行时间为 `100n` 的 `O(n)` 算法在小规模 `n` 下可能比运行时间为 `2n log n` 的 `O(n log n)` 算法慢。但在非常大的 `n` 下，`O(n log n)` 最终会超过 `O(n)`。
>
> :::

#### 【2.2.8】小结

> **时间复杂度 (`O(f(n))`) 是一种理论工具，用于描述随着输入数据量 (`n`) 的增加，一个算法执行所需时间的增长速率（增长率）。它让我们能够抽象掉硬件和实现细节，专注于算法本身的效率特性，尤其是在处理大规模数据时。理解时间复杂度对于选择、设计和分析高效算法至关重要。**

> 简单来说：时间复杂度告诉你，当你的数据量变得非常大的时候，你的算法会变得有多“慢”。数字越大（如 `n²`, `2ⁿ`），算法在大数据上的表现越糟糕；数字越小（如 `log n`, `n`），算法的效率就越高，越能处理大规模问题。

## 【3】额外的空间复杂度

### 【3.1】定义

> ::: info 额外的空间复杂度
>
> <b>空间复杂度</b>是计算机科学中用于‌**量化算法在运行过程中所需额外内存空间随输入规模增长的度量标准**‌，通常使用大O符号（`O(f(n))`）表示。它关注的是算法使用的额外内存（除输入数据本身外）如何随输入规模n（如数据元素数量）增加而变化的趋势。<b>空间复杂度</b>有助于评估算法的内存效率，尤其在大规模数据处理时至关重要。
>
> :::

### 【3.2】核心概念

> - <b>输入规模（n）：</b>表示算法处理的数据量大小（例如，排序中的元素数量）。
> - **额外空间**‌：算法运行时除输入数据外所需的辅助内存（如临时变量、递归栈、额外数组等）。
> - **增长趋势**‌：空间复杂度忽略常数因子和低阶项，只关注n增大时的主导增长率。

### 【3.3】常见空间复杂度类别

> <b>空间复杂度</b>从低到高排序，效率递减：
>
> - <b>O(1)（常数空间）</b>
>   - 算法运行时所需额外空间固定，与输入规模`n`无关。
>   - 例子：选择排序、冒泡排序、插入排序（原地交换，仅需少量临时变量）.
> - <b>O(log n)（对数空间）</b>
>   - 额外空间随n对数增长，增长缓慢（如递归算法的栈空间）。
>   - 例子：快速排序（平均情况，递归调用深度为`log n`）.
> - <b>`O(n)`（线性空间）</b>
>   - 额外空间与n成正比（例如，需要与输入大小相当的额外数组）。
>   - 例子：归并排序（需额外数组存储合并结果）.
> - <b>O(n²)（平方空间）</b>
>   - 额外空间与`n²`成正比，内存消耗随`n`急剧增加。
>   - 例子：某些动态规划算法（如矩阵乘法中需二维辅助数组）。

### 【3.4】空间复杂度的应用与重要性

> - **算法选择依据**‌：在内存受限环境（如嵌入式系统）中，优先选择低空间复杂度算法（如`O(1)`的选择排序）.
> - **时间与空间权衡**‌：高效算法常需权衡时间与空间（例如，归并排序`O(n)`空间换`O(n log n)`时间）
> - **适用场景**‌：
>   - `O(1)`空间算法适合小规模数据或资源受限场景。
>   - `O(n)`或更高空间算法适用于内存充足但追求时间效率的任务。

## 【4】参考资料

- [B站免费的左程云算法结构基础课](https://www.bilibili.com/video/BV1Ef4y1T7Qi/?spm_id_from=333.788.recommend_more_video.1&vd_source=65c7f6924d2d8ba5fa0d4c448818e08a)