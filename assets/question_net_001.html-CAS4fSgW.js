import{_ as i,c as p,b as s,d as o,a as t,w as l,r as c,o as u,e}from"./app-GRT9i7xS.js";const r={},d={class:"table-of-contents"};function m(v,n){const a=c("router-link");return u(),p("div",null,[n[6]||(n[6]=s("h2",{id:"什么是全双工、半双工",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#什么是全双工、半双工"},[s("span",null,"什么是全双工、半双工?")])],-1)),s("nav",d,[s("ul",null,[s("li",null,[t(a,{to:"#什么是全双工、半双工"},{default:l(()=>n[0]||(n[0]=[e("什么是全双工、半双工?")])),_:1,__:[0]}),s("ul",null,[s("li",null,[t(a,{to:"#_1-‌-全双工通信-full-duplex"},{default:l(()=>n[1]||(n[1]=[e("1. ‌ 全双工通信(Full Duplex)")])),_:1,__:[1]})]),s("li",null,[t(a,{to:"#_2-‌-半双工通信-half-duplex"},{default:l(()=>n[2]||(n[2]=[e("2. ‌ 半双工通信(Half Duplex)")])),_:1,__:[2]})]),s("li",null,[t(a,{to:"#_3-‌-单工通信-simplex"},{default:l(()=>n[3]||(n[3]=[e("3. ‌ 单工通信(Simplex)")])),_:1,__:[3]})]),s("li",null,[t(a,{to:"#java网络编程中的体现"},{default:l(()=>n[4]||(n[4]=[e("Java网络编程中的体现：")])),_:1,__:[4]})]),s("li",null,[t(a,{to:"#关键区别图示"},{default:l(()=>n[5]||(n[5]=[e("关键区别图示：")])),_:1,__:[5]})])])])])]),n[7]||(n[7]=o(`<blockquote><p>说在前面的话，本文为日常开发过程中遇到的一些问题，整理记录成模块，方面后续遇到直接查询解决。</p></blockquote><p>在计算机网络中，&quot;全双工&quot;和&quot;半双工&quot;描述了数据流动的方式：</p><h3 id="_1-‌-全双工通信-full-duplex" tabindex="-1"><a class="header-anchor" href="#_1-‌-全双工通信-full-duplex"><span>1. ‌ 全双工通信(Full Duplex)</span></a></h3><ul><li>‌<strong>定义</strong>‌：通信双方可以‌<strong>同时</strong>‌发送和接收数据</li><li>‌特点： <ul><li>双向数据传输能力</li><li>发送和接收操作并行进行</li><li>需要独立的发送和接收信道</li></ul></li><li>‌<strong>类比</strong>‌：电话通话（双方能同时说话和听对方说话）</li><li>‌<strong>Java示例</strong>‌：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">// 服务端响应客户端后继续监听新消息</span></span>
<span class="line">client<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 发送响应</span></span>
<span class="line"><span class="token comment">// 此时服务端可继续处理其他通道的请求</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-‌-半双工通信-half-duplex" tabindex="-1"><a class="header-anchor" href="#_2-‌-半双工通信-half-duplex"><span>2. ‌ 半双工通信(Half Duplex)</span></a></h3><ul><li>‌<strong>定义</strong>‌：通信双方可以双向传输数据，但‌<strong>不能同时</strong>‌进行</li><li>‌特点： <ul><li>交替进行发送和接收</li><li>某一时刻只能单向传输</li><li>需要通信协议协调传输方向</li></ul></li><li>‌<strong>类比</strong>‌：对讲机（按着说话键时不能听，松开才能听）</li><li>‌<strong>Java示例</strong>‌：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">// 服务端必须等待客户端发送完成才能响应</span></span>
<span class="line"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>input <span class="token operator">=</span> console<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 发送（此时不能接收）</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;等待回复...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    response <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 接收（此时不能发送）</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-‌-单工通信-simplex" tabindex="-1"><a class="header-anchor" href="#_3-‌-单工通信-simplex"><span>3. ‌ 单工通信(Simplex)</span></a></h3><ul><li>‌<strong>定义</strong>‌：数据只能‌<strong>单向传输</strong>‌</li><li>‌特点‌： <ul><li>固定方向的通信</li><li>一方只能发送，另一方只能接收</li></ul></li><li>‌<strong>类比</strong>‌：广播电台（电台只能发送，收音机只能接收）</li></ul><h3 id="java网络编程中的体现" tabindex="-1"><a class="header-anchor" href="#java网络编程中的体现"><span>Java网络编程中的体现：</span></a></h3><table><thead><tr><th>特性</th><th>BIO示例</th><th>NIO示例</th></tr></thead><tbody><tr><td>‌<strong>连接类型</strong>‌</td><td>全双工（TCP特性）</td><td>全双工（TCP特性）</td></tr><tr><td>‌<strong>实现方式</strong>‌</td><td>半双工使用方式</td><td>真正的全双工实现</td></tr><tr><td>‌<strong>原因</strong>‌</td><td>单线程顺序处理</td><td>多路复用支持并发读写</td></tr></tbody></table><h3 id="关键区别图示" tabindex="-1"><a class="header-anchor" href="#关键区别图示"><span>关键区别图示：</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">全双工：</span>
<span class="line">  客户端 →→ 数据 →→ 服务端</span>
<span class="line">  客户端 ←← 数据 ←← 服务端</span>
<span class="line">  (双向同时传输)</span>
<span class="line"></span>
<span class="line">半双工：</span>
<span class="line">  客户端 →→ 数据 →→ 服务端</span>
<span class="line">  (传输完成后)</span>
<span class="line">  客户端 ←← 数据 ←← 服务端</span>
<span class="line">  (交替传输)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际Java网络编程中：</p><ol><li>‌<strong>TCP协议本身是全双工的</strong>‌（底层支持双向同时传输）</li><li>‌<strong>BIO模型常表现为半双工</strong>‌：因为单线程顺序处理请求/响应</li><li>‌<strong>NIO/AIO可实现真正全双工</strong>‌：通过Selector多路复用，读写操作互不阻塞</li><li>‌<strong>WebSocket是全双工典型</strong>‌：建立连接后双方可随时互发消息</li></ol><blockquote><p>建议：需要实时双向通信的场景（如聊天室、游戏）应使用NIO+WebSocket实现全双工，而简单的请求-响应场景可以使用半双工模式。</p></blockquote>`,17))])}const g=i(r,[["render",m]]),b=JSON.parse('{"path":"/md/question/net/question_net_001.html","title":"","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1749796282000,"contributors":[{"name":"钱鹏展","username":"","email":"873373549@qq.com","commits":2}],"changelog":[{"hash":"4c9b250282ef75917c448ac36c31dba02872f92c","time":1749796282000,"email":"873373549@qq.com","author":"钱鹏展","message":"代码优化 加入 golang基础"},{"hash":"956690ff403c91b3d5d49d03164932c3deaab0cb","time":1749785635000,"email":"873373549@qq.com","author":"钱鹏展","message":"002 q"}]},"filePathRelative":"md/question/net/question_net_001.md"}');export{g as comp,b as data};
